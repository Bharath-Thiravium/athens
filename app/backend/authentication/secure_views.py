"""
Secure authentication views with proper password handling
"""
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from .views import CustomTokenObtainPairView
from .auth_utils import create_secure_admin_password, validate_password_reset_request, secure_password_response
import base64


def secure_create_admin_user(request_data, project, admin_type, company_data=None):
    """Securely create admin user with strong password"""
    password = create_secure_admin_password()
    
    admin_data = {
        'username': request_data.get(f'{admin_type}_username'),
        'password': password,
        'user_type': 'projectadmin',
        'project': project.id,
        'admin_type': admin_type,
        'company_name': company_data.get('company_name') if company_data else None,
        'registered_address': company_data.get('registered_address') if company_data else None,
        'is_autogenerated_password': True,
        'is_password_reset_required': True,
        'is_active': True,
    }
    
    return admin_data, password


def secure_password_reset(request):
    """Securely handle password reset with validation"""
    password_valid, message = validate_password_reset_request(request.data)
    
    if not password_valid:
        return secure_password_response(False, message)
    
    return None  # No error, proceed with reset


class SecureCompatibleLoginAPIView(APIView):
    """Secure login view that's backward compatible with existing frontend"""
    
    # Override global authentication/permission settings for login
    authentication_classes = []
    permission_classes = []
    
    def get(self, request, *args, **kwargs):
        """Handle GET requests with useful information"""
        return Response({
            'message': 'Login endpoint - use POST method',
            'method': 'POST',
            'required_fields': ['username', 'password'],
            'example': {
                'username': 'your_username',
                'password': 'placeholder_password'
            }
        }, status=status.HTTP_200_OK)
    
    def post(self, request, *args, **kwargs):
        """Handle secure login with backward compatibility"""
        from .serializers import CustomTokenObtainPairSerializer
        import logging
        
        logger = logging.getLogger(__name__)
        
        # Check if request contains encoded credentials
        if 'credentials' in request.data:
            try:
                # Decode the credentials
                encoded_creds = request.data['credentials']
                decoded_creds = base64.b64decode(encoded_creds).decode('utf-8')
                username, password = decoded_creds.split(':', 1)
                
                # Create login data
                login_data = {'username': username, 'password': password}
                
            except Exception as e:
                return Response({'detail': f'Invalid credentials format: {str(e)}'}, status=400)
        else:
            login_data = request.data
        
        # Log the login attempt (without password)
        logger.info(f"Login attempt for username: {login_data.get('username')}")
        
        # Explicitly check for required fields to provide a clearer error message
        if not login_data.get('username') or not login_data.get('password'):
            return Response({
                'detail': 'Both username and password are required.',
                'error_code': 'MISSING_CREDENTIALS'
            }, status=status.HTTP_400_BAD_REQUEST)

        # Use the serializer directly
        serializer = CustomTokenObtainPairSerializer(data=login_data)
        try:
            serializer.is_valid(raise_exception=True)
            logger.info(f"Login successful for username: {login_data.get('username')}")
            return Response(serializer.validated_data, status=200)
        except Exception as e:
            logger.error(f"Login failed for username: {login_data.get('username')}, error: {str(e)}")
            # A 401 Unauthorized is more semantically correct for failed authentication
            return Response({
                'detail': 'Invalid username or password.',
                'error_code': 'INVALID_CREDENTIALS'
            }, status=status.HTTP_401_UNAUTHORIZED)
